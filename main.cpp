/*
 ______  __    __  __     __   ______   ______   ______  ________   ______    ______   __    __
|      \|  \  |  \|  \   |  \ /      \ |      \ /      \|        \ /      \  /      \ |  \  |  \
 \$$$$$$| $$\ | $$| $$   | $$|  $$$$$$\ \$$$$$$|  $$$$$$\\$$$$$$$$|  $$$$$$\|  $$$$$$\| $$  | $$
  | $$  | $$$\| $$| $$   | $$| $$  | $$  | $$  | $$   \$$  | $$   | $$  | $$| $$__| $$| $$__| $$
  | $$  | $$$$\ $$ \$$\ /  $$| $$  | $$  | $$  | $$        | $$   | $$  | $$| $$    $$| $$    $$
  | $$  | $$\$$ $$  \$$\  $$ | $$  | $$  | $$  | $$   __   | $$   | $$  | $$| $$$$$$$$| $$$$$$$$
 _| $$_ | $$ \$$$$   \$$ $$  | $$__/ $$ _| $$_ | $$__/  \  | $$   | $$__/ $$| $$  | $$| $$  | $$
|   $$ \| $$  \$$$    \$$$    \$$    $$|   $$ \ \$$    $$  | $$    \$$    $$| $$  | $$| $$  | $$
 \$$$$$$ \$$   \$$     \$      \$$$$$$  \$$$$$$  \$$$$$$    \$$     \$$$$$$  \$$   \$$ \$$   \$$
*/
/*
+*%@@@@@%%%%%%%%%%%%%%%%%%%%%%%%%*%@@@@@@@%%@@@@@@@%%######%%%%%%@@@@@@%%@@@@@@@@@@@@@@@@%+=*%%@@@%%
=#@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*#@@@@@@%**#%##*+================+%@@@%@@@@@@@@@@@@@@@@@%+-=#%%%%%%
=#@@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#%@@@@@@#========--------=========+%@@@@@@@@@@@@@@@@@@@@%*:-*%%%%##
=%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@#%@@@@@@*=--------------===========*@@@@@@@@@@@@@@@@@@@@@#-:=#%%%##
+%@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@%%@@@@@%*=------------=====--======*%@@@@@@@@@@@@@@@@@@@@%=:-*%%%%%
#%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@%#***%@@%+------------------------==#@@@@@@@@@@@@@@@@@@@@@%+::+#%%%@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@%+==++#%#=---=++++==-----------=====%@@@@@@@@@@@@@@@@@@@@@@*-:=*%%@@
%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@%*=-+*++#*==+*###%%%#*==----=+##%%#++%@@@@@@@@@@@@@@@@@@@@@@#-:-+#%%@
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@%+::+**=+==+*###****###+===+#%@%%##**%@@@@@@@@@@@@@@@@@@@@@@%=::=*###
@%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#=:-+=::--=======+***++++**#######*#%@@@@@@@@@@@@@@@@@@@@@@@+::-+#**
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#+---::--------====+==++***++==+++*%@@@@@@@@@@@@@@@@@@@@@@@#-.:=***
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#+:..-=================++========+*%@@@@@@@@@@@@@@@@@@@@@@%=::-+++
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%*+-.:=+++==============++++++++==+#@@@@@@@@@@@@@@@@@@@@@@%+::-=+#
%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@%%%%#*=::-+=---===========+++*++**+==+#@@@@@@@@@@@@@@@@@@@@@@@*-::-+#
%%%%%%%%%%%%%%%%@@@%%%%%%%@@@@@%%%%%*=:.:=+**+=-------=======--=+===*%@@@@@@@@@@@@@@@@@@@@@@@#=::-=*
%%%%%%%%%%%%%%%%@@@@%%%%%%@@@@@@@%%%*-:..-=*%%%%*+++++++==++*#%#+=+#%@@@@@@@@@@@@@@@@@@@@@@@@%+:::-=
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@%%%*--:.:=+*#@@@@@@@@@@@@@@@@%+=+%@@@@@@@@@@@@@@@@@@@@@@@@@@@*-::::
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%+-=-.:-=+*#%@@@@@@@@@@@@@#++*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@#-:..:
@@%%@@@@%%%%%%%%%%%%%%%%%%%%%%@@@%%#=--=-::===++#@@%%%###%%@%+=*%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%=:...
@@@@@@@@@%%%%%%%%%%%%%%%%%%%@@@@@%*---:-+=---====+##******##+=+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@*:...
%@@@@@@@@%%%%%%%%%%%%%%%%%%%%@@%#:.:-:.:-**+--====+#****++++=+%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@#-:..
@@@@@@@@%%%%%%%%%%%%%%%%%%%%@%%+:...::::-=+**====-=##***++==*###%@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@%=:..
@@@@@@@@%%%%%%%%%%%%%%%%%%%%#+-.........-==+**+==-=*#****+=+*++++*#%%@@@@@@@@@@@@@@@@@@@@@@@@@@@+:..
@@@@@@@@%%%%%%%%%%%%%%%%%%*=--...........:-=++**==+*#***+++*++=----=*#%@@@@@@@@@@@@@@@@@@@@@@@@@#=..
@@@@@@@%%%%%%%%%%%%%%%#*=:.....   .........::=+**+*##***++*+++==-:..::=#@@@@@@@@@@@@@@@@@@@@@@@@@#-.
@@@@@@@%%%%%%%%%%%%#+=:.:--:....  .........:::-=*#%##****#*++++==-:....:-*%@@@@@@@@@@@@@@@@@@@@@@%=.
@@@@@@%%%%%%%%%##+=-::=*****=:......:.....:::-==+*%%#*####*++++==--::....:-*%%@@@@@@@@@@@@@@@@@@@%+:
@@%%%%%%%%%##*=---:..:+%@@%%#*-...:::::::::=*###%*%%#######*+++==---:-=--::=*%@@@@@@@@@@@@@@@@@@@%*:
%%%%%%%%%%#*=::.....-=+#@@@@@%#+:.::-:::::-*#**#%@%#***#####+++===--+*+--:-+*%@@@@@@@@@@@@@@@@@@@@#-
%%%%%%%%#+:.....:-=+#%@@@@@@@@%%*::::::::-=*****##%%##%%%%%%#*+====#*+*+--*#*+#@@@@@@@@@@@@@@@@@@@%=
%%%%%#+-.....-==+**%@@@@@@@@@@@@@#=-::::-=+#*******#@@@@@@@@@@%##%%+===+*#@@%+==*%%%@@@@@@@@@@@@@@%+
%%#+-:.....:-=*#%##%@@@@@@@@@@@@@@@#+++**##+++++====+#@@@@@@@@@%*+==-===#@@@@#+-:-+#@@@@@@@@@@%%%%%#
*=:.....-=**###%@@%%@@@@@@@@@@@@@@@@@%*###*+=++++=====+#@@@@@@@#--------+%@@@%#*=---+%@@@@@@@%%%%%%%
...:-++*#%%%%%#++%%++#@@@@@@@@@@@@@@@@%#*+====+++++++++=+%@@@@@+-----=--=#@@@@@%#*+=--+%@@@@@%%%%%%%
::=*#%%@@@@%%%%%#**##*#%%%@@@@@@@@@@@@@@#++====+++===++++*%@@@@#=---===--*@@@@@@%%#**=:-+%@@@%%%%%%%
+##%@@@@@@@@@%%#*#%@%##*%%@@@@@@@@@@@@@@%#*******#**+++==+#@@@@@%+===+===+%@@@@@@@%%%#+-:=+#%%%%%%%%
#@@@@@@@@@@@@@@%%#%%%#*#%@@@@@@@@@@@@@@@@%#**######****++*%@@@@@@#++++++++#@@@@@@@@%@@%#++=-=#%%%%%%
%@@@@@@@@@@@@@@@@@%#*#%##%@@@@@@@@@@@@@@@@%#*****##*****+*%@@@@@@%*+++++++*%@@@@@@@@@@@%%#*=::+#%%%%
=#@@@@@@@@@@@@@@@@%#%%@@%##%@@@@@@@@@@@@@@@%#*+++*******+*%@@@@@@@#+++++++*%@@@@@@@@@@@@@%%#+-:-*%%%
-=#@@@@@@@@@@@@@@@@%###%#*%%%%%@@@@@@@@@@@@@@*====+++====*@@@@@@@@%*++++==*%@@@@@@@@@@@@@@@%%*+==#%%
--=*@@@@@@@@@@@@@@@@%%##%@%##%%%%%@@@@@@@@@@@%+=-==+=====*@@@@@@@@@*+=====+%@@@@@@@@@@@@@@@@%%#=:=#%
====*%@@@@@@@@@@@@@@%##%%@@%##%%%%%%%%@@@@@@@@%+--==+++++#@@@@@@@@@#=---==+%@@@@@@@@@@@@@@@@@@%+:-*%
++===+#@@@@@@@@@@@@@@@@%%###%%%%%%%%%%%@@@@@@@@#+===+++++#@@@@@@@@@#=---==+%@@@@@@@%@@@@@%%%%@%*--*#
++++===*%@@@@@@@@@@@@@@@%#%@@%%%%%%%%%@@@@@@@@@@#*++***++#@@@@@@@@@%+=====*%@@@@@@@%@@@@%%%%%%%*==+#
+++++==+*%@@@@@@@@@@@@%%##%@@@%#%@@@%%%@@@@@@@@@@#*****++%@@@@@@@@@%*+++++*%@@@@@@%%@@@@%%%%%%%#++*#
***++++=+*%@@@@@@@@@@@%%%%%###%%@@@@@@@@@@@@@@@@@@%%@@@%#%@@@@@@@@@@*+++++#%@@@@@@%%@%%@@@@@@@%#**##
*****+++++#@@@@@@@@@@@%%%%#*#%@%%%@@@@@@@@@@@@@@@@@@%#%@@@@@@@@@@@@@#+++++#%@@@@@@%%%%%@@@@@@@%###%%
******++++*%@@@@@@@@@@@@%%%%@@@@@%@@@@@@@@@@@@@@@@@%%%@@@@@@@@@@@@@@%+++++#%@@@@@%%%%%%%@@@@@@@%##%%
*/


//OVERARCHING LIBRARIES
#include <iostream>
#include <vector>
#include <random>
#include <memory>
#include <type_traits>


//OPENGL LIBRARIES
#include<glad/glad.h>
#include<GLFW/glfw3.h>

//math libraries
#include<glm/glm.hpp>
#include<glm/gtc/matrix_transform.hpp>
#include<glm/gtc/type_ptr.hpp>
#include <glm/gtc/quaternion.hpp>

//NON MANMADES
#include <ft2build.h>
#include FT_FREETYPE_H  

//MANMADE LIBRARIES
#include "Folder.h"
#include "Physics.h"
#include "font.h"
#include "Camera.h"
#include "shaderClass.h"
#include "VBO.h"
#include "VAO.h"
#include "EBO.h"
#include "FBO.h"
#include "texture.h"
#include "Material.h"
#include "Keyboard.h"
#include "Model.h"
#include "DirLight.h"
#include "Audio.h"
#include "tFunctions.h"
#include "Debug.h"
#include "Cubemap.h"
#include "Mouse.h"
#include "QuadVertices.h"
#include "Gui.h"
#include "Particle.h"
#include "RenderSystem.h"

#define STB_IMAGE_IMPLEMENTATION
#include "stb_image.h"

int height = 720;
int width = 1280;
int fps = 60;
float lastX = width / 2.0f;
float lastY = height / 2.0f;

Camera camera(width, height, glm::vec3(0.0f, 0.0f, 2.0f));
bool firstmouse = false;

Keyboard keyboard;
Mouse mouse;

static void framebuffer_size_callback(GLFWwindow* window, int w, int h)
{
    glViewport(0, 0, w, h);
    width = w;
    height = h;
    camera.UpdateWidthHeight(width,height);
}

static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) {
    if (action == GLFW_PRESS) {
        keyboard.KeyDown(key);

    }
    else if (action == GLFW_RELEASE) {
        keyboard.KeyUp(key);
    }
}

static void scroll_callback(GLFWwindow* window, double xoffset, double yoffset) {

}

static void mouse_callback(GLFWwindow* window, double xposIn, double yposIn) {
    mouse.OnMouseMove(static_cast<float>(xposIn), static_cast<float>(yposIn));
    if (camera.lockedcursor) {
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
        float xpos = static_cast<float>(xposIn);
        float ypos = static_cast<float>(yposIn);

        if (firstmouse)
        {
            lastX = xpos;
            lastY = ypos;
            firstmouse = false;
        }

        float xoffset = -xpos + lastX;
        float yoffset = -lastY + ypos; // reversed since y-coordinates go from bottom to top

        lastX = width / 2;
        lastY = height / 2;

        camera.ProcessMouseMovement(xoffset, yoffset);
        glfwSetCursorPos(window, width / 2, height / 2);
        mouse.OnMouseMove(width/2.0f, height/2.0f);
    }
    else {
        glfwSetInputMode(window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
    }
}

static void mouse_button_callback(GLFWwindow* window, int button, int action, int mods)
{
    if (button == GLFW_MOUSE_BUTTON_RIGHT) {
        if (action == GLFW_PRESS) mouse.RightDown();
        else mouse.RightUp();
    } else if (button == GLFW_MOUSE_BUTTON_LEFT) {
        if (action == GLFW_PRESS) mouse.LeftDown();
        else mouse.LeftUp();
    }
}

static void ProcessInputs(GLFWwindow* window) {

    if (keyboard.IsKeyDown(GLFW_KEY_ESCAPE)) {
        glfwSetWindowShouldClose(window, 1);
    }

    if (keyboard.IsKeyDown('W')) {
        camera.t.TranslateBy(camera.speed * camera.t.GetFrontVector());
    }
    if (keyboard.IsKeyDown('S')) {
        camera.t.TranslateBy(-(camera.speed * camera.t.GetFrontVector()));
    }
    if (keyboard.IsKeyDown('A')) {
        camera.t.TranslateBy(camera.speed * camera.t.GetRightVector());
    }
    if (keyboard.IsKeyDown('D')) {
        camera.t.TranslateBy(-(camera.speed * camera.t.GetRightVector()));
    }
    if (keyboard.IsKeyDown(GLFW_KEY_LEFT_SHIFT)) {
        camera.speed *= 1.005;
    }
    else {
        camera.speed = camera.originalspeed;
    }
}

int main() {
    glfwInit();

    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    glfwWindowHint(GLFW_SAMPLES, 4);

    //WINDOW INITIALIZATION
    GLFWwindow* window = glfwCreateWindow(width, height, "eiifwhrn", NULL, NULL);
    if (window == NULL) {

        glfwTerminate();
        throw - 1;
    }


    glfwMakeContextCurrent(window);
    gladLoadGL();
    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);
    glfwSetCursorPosCallback(window, mouse_callback);
    glfwSetScrollCallback(window, scroll_callback);
    glfwSetKeyCallback(window, key_callback);
    glfwSetMouseButtonCallback(window,mouse_button_callback);
    glEnable(GL_DEPTH_TEST);
    glfwSwapInterval(1);
    glViewport(0, 0, width, height);

    glEnable(GL_MULTISAMPLE);
    glEnable(GL_BLEND);
    glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

    glEnable(GL_CULL_FACE);
    glCullFace(GL_BACK);
    glFrontFace(GL_CCW);

    //SHADERS
    //nonrendersystem shaders
    Shader* SkyboxShader = new Shader("shaders/skybox.vert","shaders/skybox.frag");
    Shader* ScreenShader = new Shader("shaders/ScreenShader.vert", "shaders/ScreenShader.frag");

    //rendersystem shaders
    Shader* MeshShader = new Shader("shaders/default.vert", "shaders/default.frag");
    Shader* ImageBoxShader = new Shader("shaders/ImageBox.vert", "shaders/ImageBox.frag");
    Shader* BoxShader = new Shader("shaders/Box.vert", "shaders/Box.frag");
    Shader* Text2DShader = new Shader("shaders/2DText.vert", "shaders/2DText.frag");
    Shader* ParticleShader = new Shader("shaders/Particle.vert", "shaders/Particle.frag");
    
    RenderSystem rs;
    rs.BoxShader = BoxShader;
    rs.MeshShader = MeshShader;
    rs.ImageBoxShader = ImageBoxShader;
    rs.Text2DShader = Text2DShader;
    rs.ParticleShader = ParticleShader;

    unsigned int skyboxVAO, skyboxVBO;
    glGenVertexArrays(1, &skyboxVAO);
    glGenBuffers(1, &skyboxVBO);
    glBindVertexArray(skyboxVAO);
    glBindBuffer(GL_ARRAY_BUFFER, skyboxVBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(skyboxVertices), &skyboxVertices, GL_STATIC_DRAW);
    glEnableVertexAttribArray(0);
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);

    VAO quadVAO;
    VBO quadVBO;
    quadVBO.BufferData(&quadVertices, sizeof(quadVertices));

    quadVAO.LinkVBO(quadVBO,0,2,GL_FLOAT, 4 * sizeof(float), (void*)0);
    quadVAO.LinkVBO(quadVBO, 1, 2, GL_FLOAT, 4 * sizeof(float), (void*)(2 * sizeof(float)));


    //LIGHTING

    DirLight MainDirLight(glm::vec3(0.5f), glm::vec3(0.5f), glm::vec3(0.5f), glm::vec3(0.0f, -1.0f, 1.0f));

    //


    std::vector<std::string> faces = {
        "assets/miramar_ft.tga",
        "assets/miramar_bk.tga",
        "assets/miramar_up.tga",
        "assets/miramar_dn.tga",
        "assets/miramar_rt.tga",
        "assets/miramar_lf.tga"
    };
    Cubemap skybox(faces);

    //FRAMEBUFFER
    FBO framebuffer;
    framebuffer.Bind();
    unsigned int textureColorbuffer;
    glGenTextures(1, &textureColorbuffer);
    glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    glBindTexture(GL_TEXTURE_2D, 0);
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, textureColorbuffer, 0);

    unsigned int rbo;
    glGenRenderbuffers(1, &rbo);
    glBindRenderbuffer(GL_RENDERBUFFER, rbo);
    glRenderbufferStorage(GL_RENDERBUFFER, GL_DEPTH24_STENCIL8, width, height);
    glFramebufferRenderbuffer(GL_FRAMEBUFFER, GL_DEPTH_STENCIL_ATTACHMENT, GL_RENDERBUFFER, rbo);

    if (glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        std::cout << "ERROR::FRAMEBUFFER:: Framebuffer is not complete!" << std::endl;
    framebuffer.Unbind();

    //FONTS
    std::vector<Font> fonts;

    std::string arialdirectory = "C:/Windows/Fonts/arial.ttf";
    Font* arial = new Font(arialdirectory.c_str());

    //FOLDERS
    Folder mainf;
    std::vector<Model*> cubes = {};
    std::vector<Mesh*> meshes = {};
    std::vector<Box*> gui = {};
    std::vector<ParticleEmitter*> pes;
    //EVENTUALLY CONVERGE INTO ONE FOLDER

    //game logic and shit

    Physics physicsengine;

    unsigned long int frame = 0;
    unsigned long prev = 0;

    //DEBUG/SHORTSTAY STUFF ONLY
    Audio AudioSystem;
    AudioSystem.PlayAudio(L"Agartha.wav");

    //STUFF

    ParticleEmitter* snow = new ParticleEmitter;
    snow->t.TranslateTo({ 0.0f,10.0f,0.0f });
    snow->t.RotateToQuaternion(glm::quat(glm::vec3(glm::radians(90.0f),0.0f, 0.0f)));
    snow->speed = 30.0f;
    snow->lifespan = 2.0f;
    snow->angularvelocity = {0.0f,0.0f,glm::radians(10.0f)};
    snow->size = {0.04f,0.4f,0.0f};
    snow->emitangle = {glm::radians(60.0f),glm::radians(60.0f) ,glm::radians(60.0f) };
    snow->facecamera = false;
    snow->color = {1.0f,1.0f,1.0f,1.0f};
    snow->emitdirection = ParticleEmitter::EmitDirection::Perpendicular;
    pes.push_back(snow);

    ParticleEmitter* pe = new ParticleEmitter;
    pe->t.TranslateTo({0.0f,2.0f,2.0f});
    pes.push_back(pe);

    Box* crosshair = new Box();
    crosshair->Color = {0.0f,0.0f,0.0f};
    crosshair->t2d.center = {0.5f,0.5f};
    crosshair->t2d.position = { 0.5f,0.5f,0.0f,0.0f };
    crosshair->t2d.size = {0.0f,0.0f,8.0f,8.0f};
    crosshair->rounding = 1.0f;
    gui.push_back(crosshair);

    ImageBox* testgui = new ImageBox();
    testgui->t2d.center = { 0.0f,1.0f };
    testgui->t2d.position = { 0.0f,1.0f,10.0f,-10.0f };
    testgui->t2d.size = {0.0f,0.0f,744.0f/2.0f,914.0f/2.0f};
    testgui->Color = {1.0f,1.0f,1.0f};
    testgui->Opacity = 0.8f;
    testgui->rounding = 0.1f;
    gui.push_back(testgui);

    Texture* magic = new Texture("itsmagicbitch.jpg");
    testgui->tex = magic;

    Texture* snowflake = new Texture("assets/snowflake.png");
    pe->tex = snowflake;
    snow->tex = snowflake;

    Model leiheng("leihengsword.obj");
    leiheng.t.TranslateTo({ 5.0f,4.0f,0.0f });
    leiheng.t.ScaleTo({1.0f,1.0f,1.0f});

    Mesh* floor = CreateCubeMesh();
    floor->t.ScaleTo({ 10.0f,0.4f,10.0f });
    floor->t.TranslateTo({ 0.0f,1.0f,0.0f });
    floor->InitializePhysics();
    floor->AddPhysicsToEngine(physicsengine);
    floor->p.mass = 5000.0f;
    floor->p.velocity = false;
    meshes.push_back(floor);

    Mesh* cube = CreateCubeMesh();
    cube->t.ScaleTo({ 1.0f,1.0f,1.0f });
    cube->t.TranslateTo({ 5.0f,4.0f,6.5f });
    meshes.push_back(cube);

    SkyboxShader->Activate();
    SkyboxShader->SetInt("skybox",0);

    //LOOP
    while (!glfwWindowShouldClose(window))
    {
        ////////////////////////////////////START OF LOOP///////////////////////////////////
        frame++;

        float deltatime = 1.0f / float(fps);
        
        //INPUTS
        ProcessInputs(window);

        ////////////////////////////////////LOGIC////////////////////////////////////

        while (Mouse::Event buffer = mouse.Read()) {
            if (buffer.GetType() == Mouse::Event::Type::RPress) {
                camera.lockedcursor = not camera.lockedcursor;
            } else if (buffer.GetType() == Mouse::Event::Type::LPress) {
                for (Box* box : gui) {

                    if (BoxButton* boxe = dynamic_cast<BoxButton*>(box)) {
                        //bitch ass goofy ass y is flipped bleh
                        boxe->UpdateClicked(mouse.GetX(), height - mouse.GetY());
                        
                    }
                }
            }
        }

        while (Keyboard::Event buffer = keyboard.ReadKey()) {
            if (buffer.GetCode() == 'F' and buffer.IsPress()) {
                Model* newcube = new Model("cratelookingthing.obj");
                newcube->t.TranslateTo(camera.t.GetTranslation());
                newcube->AddPhysicsToEngine(physicsengine);
                cubes.push_back(newcube);
            }
        }
        if (keyboard.IsKeyDown('Z')) {
            int initialsize = meshes.size();
            for (int i = 0; i < initialsize; i++) {
                meshes[i]->Slice(camera.t.GetTranslation(), camera.t.GetRotationQuaternion(), meshes);
            }
        }
        if (keyboard.IsKeyDown('R')) {
            pe->t.TranslateTo(camera.t.GetTranslation());
            pe->t.RotateToQuaternion(camera.t.GetRotationQuaternion());
            pe->Emit();

        }

        RayIntersectsModel({ camera.t.GetTranslation(), camera.t.GetFrontVector() * 100.0f }, leiheng);

        unsigned int onceeveryframes = 1;
        if (frame % onceeveryframes == 0) {
            /*
            if (not (cubes.size() > 2)) {
                Model* newcube = new Model("cratelookingthing.obj");
                newcube->t.TranslateTo({ rand() % 2,rand() % 100,rand() % 2 });
                newcube->AddPhysicsToEngine(physicsengine);
                cubes.push_back(newcube);
            }
            */
        }

        snow->Emit();
        snow->Emit();
        snow->Emit();
        snow->Emit();
        snow->Emit();
        snow->Emit();
        snow->Emit();
        snow->Emit();

        for (ParticleEmitter* pe : pes) {
            pe->Step(deltatime);
        }

        physicsengine.Step(deltatime);
        /*
        if (frame % 2 == 0) {
            physicsengine.Step(1.0f / 30.0f);
        }
        */

        ////////////////////////////////////RENDER SCENE////////////////////////////////////

        //BIND FRAMEBUFFER
        
        framebuffer.Bind();

        glEnable(GL_DEPTH_TEST);

        //IMPORTANT
        glClearColor(212. / 255., 223. / 255., 232. / 255., 1.0f);
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

        ////////////////////////////////////SKYBOX////////////////////////////////////
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
        glDisable(GL_DEPTH_TEST);  // change depth function so depth test passes when values are equal to depth buffer's content
        SkyboxShader->Activate();
        SkyboxShader->SetMat4("proj", camera.GetProjectionMatrix(90.0f, 0.05f, 2000.0f));
        SkyboxShader->SetMat4("view", glm::mat4(glm::mat3(camera.GetViewMatrix())));
        // skybox cube
        glBindVertexArray(skyboxVAO);
        glActiveTexture(GL_TEXTURE0);
        skybox.Bind();
        glDrawArrays(GL_TRIANGLES, 0, 36);
        glBindVertexArray(0);
        glEnable(GL_DEPTH_TEST);

        //CELESTIAL BODIES

        //one day

        ////////////////////////////////////RENDER STUFF////////////////////////////////////

        MeshShader->Activate();

        glm::mat4 proj = camera.GetProjectionMatrix(90.0f, 0.05f, 2000.0f);
        glm::mat4 view = camera.GetViewMatrix();
        camera.Matrix(90.0f, 0.05f, 2000.0f, *MeshShader);

        //LIGHTING STUFF

        MainDirLight.Bind(*MeshShader);

        //SCENE

        
        //mat


        //testtex.Unbind();

        for (int i = 0; i < cubes.size(); i++) {
            cubes[i]->Render(*MeshShader);
        }

        for (Mesh* mesh : meshes) {
            mesh->Render(*MeshShader);
        }

        leiheng.Render(*MeshShader);
        
        glDisable(GL_CULL_FACE);
        ParticleShader->Activate();
        ParticleShader->SetMat4("proj", proj);
        ParticleShader->SetMat4("view", view);
        for (ParticleEmitter* pe : pes) {
            pe->Render(*ParticleShader,camera);
        }
        glEnable(GL_CULL_FACE);
        //unbind stuff
        glBindVertexArray(0);

        ////////////////////////////////////SCENE FRAMEBUFFER////////////////////////////////////
        
        framebuffer.Unbind();
        glDisable(GL_DEPTH_TEST);
        glClearColor(0.0f,0.0f,0.0f, 0.0f);
        glClear(GL_COLOR_BUFFER_BIT);

        ScreenShader->Activate();
        
        //ScreenShader.Set1F("saturation", sin((float)frame/15) * 1.0f + 1.0f);
        quadVAO.Bind();
        glActiveTexture(GL_TEXTURE0);
        glBindTexture(GL_TEXTURE_2D, textureColorbuffer);
        glDrawArrays(GL_TRIANGLES, 0, 6);
        
        ////////////////////////////////////GUI////////////////////////////////////

        for (Box *box : gui) {
            if (box->Opacity == 0.0f) continue;
            
            if (ImageBox* boxe = dynamic_cast<ImageBox*>(box)) {
                box->Render(*ImageBoxShader, width, height);
            }
            else if (TextBox* boxe = dynamic_cast<TextBox*>(box)) {
                boxe->Render(*BoxShader, width, height);
                boxe->RenderText(*Text2DShader,width,height);
            }
            else {
                box->Render(*BoxShader, width, height);
            }
        }

        
        ////////////////////////////////////END OF FRAME////////////////////////////////////
        glfwSwapBuffers(window);
        glfwPollEvents();
    }



    glfwDestroyWindow(window);
    glfwTerminate();
    return 0;
}